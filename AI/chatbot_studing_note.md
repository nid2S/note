# ChatBot
- 챗봇 : 음성이나 문자를 통한 인간과의 대화를 통해 특정 작업을 수행하도록 제작된 컴퓨터 프로그램. 이를 구현하기 위한 다양한 API가 존재함. 
- 동작방식 : 자연어처리를 심각하게 적용하는 언어 이해 방식, 입력에서 특정 단어/어구를 검출해 준비된 응담을 출력하는 검색방식, 각본을 미리 만든 뒤 그에 따르는 각본방식이 있음.

## 대화 시스템
- 대화시스템(Dialogue Systems) : 사람과 기계가 대화를 나눌 수 있게 하는 AI시스템. 인공지능 어플리케이션에서 필수적인 기능. 목적지향 대화시스템과 대화지향 대화시스템으로 분류됨.
- 대화처리기술 : 사용자의 말을, 명령어 중에서 정확히 이해하는 수준에서 이해하고 공감하며 전문분야수준의 지식으로 사용자 요구를 만족시키는 기술수준까지 포함. 기계가 인간의 대화 능력과 지식을 가져, 
  인간의 역할이 가능하도록 하는 기술을 이로 보기도 함. 세분화된 특정 기술 및 능력에 집중되어 발전해 왔으나, 여러 시스템들이 결합해 인간대화를 처리하도록 하고 있음. 

### 목적지향 대화시스템
- 목적지향 대화시스템(goal-oriented dialogue system) : 특정 목적을 위해 구축된, 사용자가 자연어 형태의 음성이나 텍스트 입력을 통해 원하는 작업을 수행할 수 있도록 도와주는 대화시스템. 
  사용자가 시스템과의 대화를 통해 달성하고자 하는 목표가 있고, 시스템과 연결되어있는 대용량 DB가 있어, 거기서 원하는 정보를 찾아 전달해 주는 것을 목적으로 함. 문제해결용 대화시스템과 사실상 동일.

- 문제해결용 대화시스템(Task-Oriented Dialog Systems, 기능지향 대화시스템) : 문제의 해결을 위해 설계된 시스템. 보통 NLU, DM, NLG 3개의 모듈 아키텍쳐로 구성됨. 파이프라인 목적지향.
  최대한 적은 대화로 유저가 원하는 것을 이해하고 해결하는데 초점. 문장의 의도를 알아내는 Intent Classification과 구체적인 요청을 알아내는 Slot Filling으로 구성.  
- NLU(자연어 이해) : 사용자의 발화를 이해하기 위한 모듈. intent(Search-Weather)와 Slot(location(Seoul), date(2020-05-17)등)을 분석함.
- Dialogue Manager(DM, 대화관리) : 주고받는 대화흐름을 관리. 크게 DialogStateTracker(대화추적관리/대화진행중 데이터유지)와 PolicyManager(시스템 액션결정. NLG/DB로 연결)로 구성.
- NLG(자연어 생성) : DM으로부터 데이터를 입력받아 사람이 이해할 수 있는 시스템의 응답을 생성. 각 시스템의 페르소나를 결정할 수 있기에 매우 주의깊게 다뤄져야 함.

- DM분류 : 유한상태 기계기반 방법 - 시스템 주도로 대화를 진행, 정의한 순서대로 발화하며 사용자의 응답이 적합해야 다음으로 넘어감. 쉬운구현/안정적성능/단순목적적합 장점과 일방적/제한된 대화 단점. |
  양식기반 방법 - 양식채우기 방식이라고도 함, 필수 정보를 슬롯으로 정의하고 여러 슬롯의 양식이 채워질 때 까지 대화로 정보를 요구함. 대화순서에서 자유도를 누림. 대화이해정확도 필요. | 두가지로 나뉨. 

- 대화지향 For 목적지향 : 챗봇을 특정 목적을 위해 타 프로그램과 같이 사용하는 경우, 챗봇또한 목적지향의 범주에 들어갈 수 있음(영어 교육을 위한 챗봇+문법교정 시스템 등).

### 대화지향 대화시스템
- 대화지향 대화시스템(Chat-oriented Dialog Systme) : 대화를 위해 제작된 시스템. 유저가 어떠한 주제로 말을 걸어도 알맞은 답변을 해 대화를 이어나감. 자유주제(OpenDomain)대화시스템이라고도 함.
  지속적으로 유저의 흥미를 유발해 최대한 긴 대화를 하는 것이 목적. Chit-Chat 대화시스템, 대화 에이전트라고도 함. 대화시스템에서는 이 Task를 챗봇이라고 칭함.
- 방법 종류 : 규칙/패턴기반 방법(패턴지식+제약규칙+유의어/관련어 규칙사용. 거의 자연어분석/사용자의도 이해 과정이 불필요), 검색기반 방법, 생성기반 방법(통계기반 자동번역/신경망기반 자동번역)이 있음. 
  대용량 데이터셋의 사용이 가능해짐에 따라 최근에는 규칙/패턴기반 방법과 검색기반 방법을 함께 사용하고 있음. 복잡한 구조의 표현을 위해 스크립트 언어를 사용하는 챗봇이 많음.
- 학습 : 과거엔 학습을 위해 방대한 데이터에 직접 annotation해 hand-crafted feature를 선별했지만, 도메인 영역이 작을 수 있고 모델 개발까지 오랜 시간을 걸릴 수 있다는 단점이 있었음.
  이의 해결을 위해 End-to-end 방식(hand-crafted feature에 의존적이지 않으며, 긴 대화 유지에 유용함)을 사용함. 데이터는 대부분 대용량의 대화예문(발화-응답, 텍스트/패턴형식 가능)을 사용.

- 생성 대화 모델(Generative Conversational model) : seq2seq모델을 이용해 유저의 말을 읽고 답변을 한단어씩 생성하는 모델. 많은 연산량이 필요하고, 고품질을 위해 큰 모델과 데이터셋이 필요함.
- 한계 : Maximun Likelihood로 학습되는 seq2seq특성상 답변이 평이해지기 쉽고, 많은 사람의 데이터를 섞어 학습해 일관성이 없으며, 긴 대화를 이끌고, 모르는걸 물어보고, 인간이 가르칠 수 없었음.

- 검색 기반 모델(Retrieval-based model) : DB에서 답변을 고르는 모델방식. 생성 대화 모델의 보완을 위해 탄생. DB에서 그럴듯한 N개의 답변 후보를 뽑은 뒤 한개의 답변을 선택함. 이루다의 방식.
  NLU(텍스트로 구성된 메세지를 벡터로 변환, BERT구조)모듈과 답변후보들이 저장된 DB, Re-ranker(최종답변선택을 위한 모델)로 구성됨. DB의 답변들은 실제사람이 쓴것이기에 자연/개인정보 유출 위험.
  사용자 발화는 질의로, 대용량 대화예문의 발화는 가상의 문서로 생각해 유사한 발화가 검색되면 그 발화의 응답을 시스템 응답으로 출력함. 혹시 유사예문이 없다면 임의발화를 쓰거나, 생성모델적용이 가능.

#### Breakdown Detection
- breakdown : 시스템이 대화의 흐름에 맞지 않는 발화를 생성했을 때 발생. 크게 멀티 턴으로 인해 시스템이 의도를 잘 못 이해하거나, 대화에서 많은 주제를 다뤄 모든 흐름파악에 어려움을 겪어 발생함.
- Breakdown Detection : 사람과 시스템 사이의 대화에서 문맥의 흐름이 끊겨 사람이 더이상 대화를 이어나갈 수 없을 때(breakdown), 시스템의 발화가 breakdown을 유발하는지 탐색하는 것. 
  자연스러운 대화 유지를 위한 필수 task이며, 시스템이 잘못 발화한 경우에 대한 오류 발견에도 활용가능. End-to-end방식에 대한 연구에도 불구하고, 일일히 문맥흐름을 파악해 감지하기에는 어려움이 있음.
- 초기 연구 : 각 발화에 대한 키워드 추출을 통해 breakdown되기까지 휴리스틱규칙을 이용한 rule-based방법(전통)과 LSTM을 이용해 빈번히 나오는 단어(벡터)를 feature로 구성하는 방법이 있었음(딥러닝). 
  규칙기반(전통적인)방법은 휴리스틱하게 일일히 비교해보며 찾아야 해 시간이 많이 소비되며, 딥러닝기반의 모델도 멀티 턴을 모두 반영하기에는 부족함이 있음.
- Memory attention기반 Temporal Utterance Encoding모델 : 사용자 및 시스템 발화에 대한 문장표현을 수행한 뒤 둘을 연결, LSTM > 지금까지의 메모리를 이용힌 어텐션 가중치를 얻어 예측.



















# REFERENCE
- [1](https://ettrends.etri.re.kr/ettrends/178/0905178006/34-4_55-64.pdf)
- [2](https://jiho-ml.com/weekly-nlp-31/)
- [3](https://www.koreascience.or.kr/article/CFKO201832073078524.pdf)
- [4](https://www.koreascience.or.kr/article/JAKO201734963782120.pdf)
