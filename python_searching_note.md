# print
***
- print(a,b,c,sep=',') > 사이를 sep 로
- print(a,end='') > 끝을 end 로
- 문자열은 \로 줄바꿈을 한 뒤 입력해 여러줄에서 입력할 수 있다.

# comment
- \# : 파이썬의 주석. 코드 실행시 인식하지 않음.
- \# TODO : PyCharm의 할일 관리 기능. 파이참의 TODO항목에서 한눈에 볼 수 있음. todo가 있으면 커밋불가.
- """ """ : docstring. 클래스/메서드/함수등의 사용자가 알아야 할 설명을 추가. 해당객체.__doc\_\_로 확인가능. ''' '''로도 사용은 가능.
- annotation : 클래스/메서드/함수 에서 입력값과 반환값의 존재/자료형을 알려주는 주석. [함수(변수: 자료형) -> 반환자료형: 코드] 으로 사용.

#sequence
***
- 개체 : entity. 클래스에 속한 값(속성), 메서드 등을 의미함.
- 객체 : object. 어떠한 속성값과 행동을 가지고 있는 데이터(==클래스()). 파이썬의 모든것.
  
- 시퀀스자료형 : 투플,리스트,range,문자열등 값이 연속적으로 이어진 자료형
- 시퀀스 객체 : 시퀀스 자료형으로 만든 객체. 요소는 시퀀스 객체속 각 값. a[0\]식으로 요소에 접근 가능
- 리스트, 튜플, 딕셔너리, 세트를 컨테이너라고 부름.
  
- id(객체) : 해당 객체의 주소값 반환.

##list
***
- s=list()/[]
- ra=[15,25,35\]               # 리스트 패킹. 투플의 경우 투플 패킹
- 리스트 = [값, 값, 값\]         # 리스트 만들기
- 리스트 = []                   # 빈 리스트 만들기
- 리스트 = list()               # 빈 리스트 만들기
- 리스트 = list(range(횟수))     # range 로 리스트 만들기

### list attribute
***
- 리스트.append(요소) = 리스트 끝에 요소 하나 추가. append([])로 리스트 안에 리스트를 넣을 수 있음. 이 리스트 안에 요소를 넣으려면 리스트[0\].append().
- 리스트.extend(리스트) = 리스트에 리스트 연결,확장.
- 리스트.insert(인덱스,요소) = 인덱스에 요소 추가. 리스트[a:a\] = [s:d\]로 특정 인덱스에 리스트 삽입 가능

- 리스트.pop() = 리스트에서 마지막 요소 삭제 후 삭제된 요소 반환. pop(인덱스)로 인덱스의 요소 삭제. del(리스트[인덱스\])로 해도 무방.
- 리스트.remove(값) = 리스트에서 값을 찾아 삭제. 중복이 있으면 처음의 하나만 삭제.

- 리스트.index(값) = 리스트에서 값의 인덱스를 찾아줌.
- 리스트.count(값) = 리스트에서 값의 개수를 구함.
- 리스트.reverse() = 리스트 뒤집기

- 리스트.sort(reverse=False / reverse=True) = 오름/내림차순 정렬. 자기자신이 정렬됨.
- sorted(리스트) = 정렬된 새 리스트 생성. key=lambda item:수식, reverse=bool 등을 인자로 주어 정렬 기준, 반전 여부 등을 선택할 수 있음.

- 리스트.clear() = del 리스트[:\] = 리스트 모든 요소 삭제,
- 리스트2 = 리스트1.copy() == 리스트 복제. 리스트2=리스트1는 할당으로, 리스트 1과 2가 가리키는 리스트는 동일함.
- for b,a in enumerate(리스트) = 리스트의 요소들을 a에,인덱스를 b에 꺼냄. (리스트,|start=|1)로 인덱스의 시작을 정할 수 있음.
- 큐 = deque(리스트) 자료형 제공. popleft()/appendleft()로 왼쪽에 요소 삭제/추가.
- 회문 판별(뒤집기) = s[::-1\], list(reversed(s)), "".join(reversed(s))

### list comprehension
- 리스트 표현식
- [식 for 변수 in 리스트\] 의 형식으로 사용. [i for i in range(10)\] 로 0부터 9까지의 리스트를 생성할 수 있다.
- [식 for 변수 in 리스트 if 조건식\] 식으로 if 문 도 사용할 수 있다.
- for 를 여러번 쓰면 뒤에서 부터 적용된다. 

## map,split
***
- a,b,c=map(int,input("정수 셋 입력 : ").split())  # 리스트 반환. 리스트로 변수 여러개 생성.
- map 은 리스트등 시퀀스 변환시만 사용. L-value 여러개. split()도 여러 자료를 입력할때만 사용. 하나의 자료를 입력받을땐 input().
- a,b=input().split()

## range
***
- range(횟수)
- range(시작, 끝), 끝은 범위에 포함되지 않음.
- range(시작, 끝, 증가폭)

## tuple
***
- 튜플 = (값, 값, 값)          # 튜플 만들기
- 튜플 = 값, 값, 값            # 괄호 없이 튜플 만들기
- 튜플 = ()                    # 빈 튜플 만들기
- 튜플 = tuple()               # 빈 튜플 만들기
- 튜플 = tuple(list())         # tuple 에 list()를 넣어서 빈 튜플 만들기
- 튜플 = tuple(리스트)         # tuple 에 리스트를 넣어서 튜플 만들기
- 튜플 = tuple(range(횟수))    # range 로 튜플 만들기
- 튜플 = (값, )                # 요소가 한 개인 튜플 만들기
- 튜플 = 값,                   # 요소가 한 개인 튜플 만들기

##calc
***
- 값 in 시퀀스객체             # 시퀀스 객체에 특정 값이 있는지 확인
- 값 not in 시퀀스객체         # 시퀀스 객체에 특정 값이 없는지 확인

- 시퀀스객체1 + 시퀀스객체2    # 시퀀스 객체를 서로 연결하여 새 시퀀스 객체를 만듦
- 시퀀스객체 * 정수            # 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듦
- 정수 * 시퀀스객체            # 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듦

- len(시퀀스객체)              # 시퀀스 객체의 요소 개수(길이) 구하기
- 시퀀스객체[-음수\]            # 인덱스를 음수로 지정하면 뒤에서부터 요소에 접근, -1은 뒤에서 첫 번째
- del 시퀀스객체[인덱스\]       # 시퀀스 객체의 요소를 삭제

##slice
***
- 시퀀스객체[시작인덱스:끝인덱스\]                 # 지정된 범위의 요소를 잘라서 새 시퀀스 객체를 만듦
- 시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭\]      # 인덱스 증가폭을 지정하면 해당 값만큼 인덱스를 증가시키면서 요소를 가져옴
- 시퀀스객체[::증가폭\]                         # 객체 전체에서 증가폭만큼 인덱스를 증가시키면서 요소를 가져옴
- del 시퀀스객체[시작인덱스:끝인덱스\]            # 특정 범위의 요소를 삭제(원본 객체가 변경됨)

### list,tuple
***
- 리스트를 만든 뒤 tuple(), 투플을 만든뒤 list()로 서로 변환 가능.
- 리스트와 투플 안에 문자열을 만들면 한 문자씩 들어가 생성.
- min(반복가능 객체),max(리스트등),sum(시퀀스) = 최솟값,최댓값,합계
- 리스트 뿐 아니라 투플에도 활용가능. 아래의 경우 tuple(식).
- [i for i in range(10)\], [i+5 for i in range(5)\], [i for i in range(10) if i%2==0\], [i * j for j in range(2, 10) for i in range(1, 10)\] 등 
  리스트 표현식에서 반복,조건문 사용 가능. 처리순서는 뒤에서부터.

## list unpacking
***
- for x,y in [[10,20\],[30,40\]\] 등으로 for 문 한번만 사용이 가능. for 뒤의 변수와 안쪽 리스트의 요수 수가 일치해야함.
- for i in [[10,20,30\],[40,50,60\]\]: for j in i: 로 중첩 for 문 사용 가능.
- [[0 for j in range(2)\] for i in range(3)\], [[0\] * 2 for i in range(3)\] 로 2차원 리스트 생성.
- [[0\] * i for i in [3, 1, 3, 2, 5\]\] 식으로 톱니형 리스트 생성.
- 정렬은 sorted(리스트, key=lambda student: student[기준이 될 인덱스\], reverse=))로 안쪽 인덱스 정렬.

### list copy
***
- 2차원 리스트를 복사하려면 import copy/ 변수 = copy.deepcopy(리스트) 로 복사.

## dictionary
***
- 딕셔너리 = {키1: 값1, 키2: 값2}    # 딕셔너리 만들기
- 딕셔너리 = {}                      # 빈 딕셔너리 만들기
- 딕셔너리 = dict()                  # 빈 딕셔너리 만들기

- 딕셔너리[키\]                       # 딕셔너리에서 키로 값에 접근
- 딕셔너리[키\] = 값                  # 딕셔너리에서 키에 값 할당

- 키 in 딕셔너리                     # 딕셔너리에 특정 키가 있는지 확인
- 키 not in 딕셔너리                 # 딕셔너리에 특정 키가 없는지 확인

- len(딕셔너리)                      # 딕셔너리의 키 개수(길이) 구하기

- vars(딕셔너리) : 객체의 __dict\_\_속성 반환. 해당 객체의 키와 value를 모두 확인 가능.

### zip
***
- zip(a, b) > 동일한 개수로 이루어진 자료형을 묶어줌.
- [1,2,3,4\]와 ['one','two','three','for'\]가 있다면 [(1,'one'), ... \]
```python
# 보통 이런식으로 사용한다.
number_l=[1,2,3]
name_l=['one', 'two', 'three']
dic = dict()
for number , name in zip(number_l,name_l):
    dic[number] = name
```

### about dict
***
- 딕셔너리 : 연관 값을 묶어 제공하는 용도.(키-값 형태의 자료형을 해시,해시맵,해시테이블등으로 부르기도 함)

- a={"a":97,"b":98,"c":99}의 형식으로 사용. # 키 이름 중복시 뒤의 값만 저장.
- 키는 정수,실수,문자열,불등 가능/ 값에는 리스트등 모든 자료형 사용 가능.

- a=dict(a=97,b=98,c=99)(키=값)
- dict([(a,97),(b,98)\])(리스트 안에 (키,값))(키는 자동으로 문자열로 바뀜)
- a=dict(zip([a,b\],[97,98\]))리스트 혹은 튜플로 키,값
- dict({a:97,b:98})

- 키의 개수=값의 개수=len()으로 구할 수 있음.
- 딕셔너리는 키로 접근 #a["a"\]=65  # 딕셔너리에 없는 키 입력 시 할당 후 추가.

### dict calc
***
- 딕셔너리.setdefault("키",값) = 딕셔너리에 쌍 추가. 값이 없으면 키에 none.
- 딕셔너리.update(키=값) = 키의 값 수정. 만약 키가 없다면 새로 추가. 키=값,키=값으로 여러개 한번에 수정 가능.
- update 는 키가 문자열일때만 사용가능. 키가 숫자면 (딕셔너리(바꿀 키 : 값))로 수정가능. ()안에는 리스트, 튜플등 반복가능객체 모두 가능. [[키1,값1\],[키2,값2\]\]형으로 이뤄져야함.

- 딕셔너리.pop(키,기본값) = 키가 있으면 키-값 삭제 후 값 반환, 없으면 기본값 반환
- del 딕셔너리["키"\]로 키 삭제.
- 딕셔너리.popitem() = 딕셔너리 마지막 값 삭제 후 튜플로 반환.
- 딕셔너리.clear() = 딕셔너리 모든 값 삭제.

- 딕셔너리.get(키,기본값) = 키가 있으면 값을 가져오고 없으면 기본값 반환. 기존값 없어도 가능.
- 딕셔너리.items() .keys() .values() = 키와 값, 키들, 값들 가져옴.

- 변수 = dict.fromkeys(키들,값) = 키들에 모두 값을 채워 딕셔너리 제작. 값이 없으면 None 채움.

- dict 나 딕셔너리[키\]에서 없는 키를 선택하면 오류.
- 이 오류를 없애기 위해 딕셔너리 = defaultdict(자료형)으로 기본값 생성.

### for dict
***
- for 에서 딕셔너리를 뽑으면 키만 뽑힘.
- {키:값 for 키, 값 in 딕셔너리 if 조건}
- {키:{키:값},키2:{키2:값2}}식으로 중첩 딕셔너리. 접근은 딕셔너리[바깥키\][안쪽키\]로 함.
- 딕셔너리도 리스트와 마찬가지로 단일은 딕셔너리.copy(), 중첩은 copy 모듈의 copy.deepcopy(딕셔너리)로 복사해야 완전복사됨.
- 딕셔너리에서 키의 개수는 len(딕셔너리)로 구할 수 있음.
- 딕셔너리의 병합은 ,update(딕셔너리)나 {**딕셔너리,**딕셔너리2}로 가능함.

# if
***
- if 조건식:
-    코드
-    여러줄도 가능 #Pass로 생략가능.
- else: 로 else,
- elif: 로 if else 사용. 빈 문자열, none,빈 시퀀스,0등은 전부 false.나머진 true
- 조건에서 and,or 사용가능. A and B. 0<=a<2같이 부등호를 연달아 사용하는것도 가능. & ,A not B, | 등 불가. not A로 사용

- for 변수 in range(횟수(range 의 기능-증가폭 등-사용 가능),변수도 가능)(기타 시퀀스 겍체들도 사용 가능): reversed 로 순서 뒤집기 가능.
-    코드     로 반복문 사용.  시퀀스 객체의 자료들을 하나씩 꺼내 변수에 대입 후 문장실행.

- 삼항연산 : 참일 경우 if 조건식 else 거짓일 경우  의 형식으로 삼항연산자 사용가능. 

# while
***
- i=0
- while i<100:
-    print("Hello")
-    i+=1    로 while 반복문 사용
-    break #continue

## rand
***
- import 로 모듈호출. random => random.random()으로 난수 호출. .randint(a,b)는 a부터 b 사이의 정수 랜덤. .choice(시퀀스)는 시퀀스 객체 속에서 랜덤 호출.

# string calc
***
- 문자열.replace("바꿀 문자열","새 문자열") = 문자열 변경 후 결과 반환.
- 테이블명 = str.maketrans("바꿀 문자-들-","새문자-들-")로 테이블 생성후 문자열.translate(테이블명)으로 문자변환.
- 문자열.split() = 공백 기준으로 분리해 리스트화. 안에 문자를 넣으면 기준 문자열대로 분리.
- 구분자문자열.join(문자열 리스트) = 구분자 문자열을 사이에 넣어 문자열들을 연결.
- 문자열.upper(), 문자열.lower() = 문자열 전부 대문자,소문자화
- 문자열.lstrip(), 문자열.rstrip(), 문자열.strip() = 왼쪽,오른쪽,양쪽에서 공백제거. (".")식으로 안에 문자를 넣으면 그 문자 삭제. (".,")식으로 여러 문자를 넣으면 문자 전부 삭제.
- import string / .strip(string.punctuation)으로 구두점(대부분의 문장기호)삭제. 공백도 삭제하고 싶으면 =" " 또는 뒤에 .split()한번 더 붙이기(메서드 체이닝, 앞에서부터)

- 문자열.ljust(길이),rjust(길이),center(길이) : 공백을 포함해 길이만큼 왼쪽,오른쪽,중간에 정렬(배치). 중간의 경우 홀수면 왼쪽에 하나 더.
- 문자열.zfill(길이) : 길이에 맞게 왼쪽에 0을 채움.
- 문자열.find/rfind(찾을 문자열) : 찾는 문자열이 가장 처음 나온 곳의 인덱스 반환, 없으면 -1 반환. 찾기 시작할 위치를 같이 인자로 넣을 수 있음. 
- 문자열.index/rindex(찾을 문자열) : find와 동일하나 없으면 에러.
- 문자열.count("문자열") : 문자열에서 문자열이 나오는 개수 반환.
- 문자열.startswith(시작문자) : 문자열이 특정문자로 시작하는지 여부 반환. 시작지점을 인자로 줄 수도 있음.
- 문자열.endswith(끝문자) : 문자열이 특정 문자로 끝나는지 여부 반환. 문자열의 시작과 끝을 인자로 줄 수도 있음.

- r"" : 문자열을 raw문자열로 인식하게 함. \가 \\로 인식되어 출력되게 됨.


## format
***
- 문자열(안에 {인덱스}).format(값들) = 인덱스 부분에 format 부분 속 인덱스에 맞는 값 삽입. 같은 인덱스를 여러개 넣거나 인덱스를 생략해도 됨.
- 인덱스 대신 format 에 (이름=값)으로 지정 후 {이름}을 넣어주는 것도 가능.
- 변수에 값을 넣고 f문자열(속에 {변수})로 간단 포매팅 가능.
- {인덱스(생략가능) : 방향(<,>)길이}.format(값)으로 ljust,rjust,center 처럼 정렬가능.
- "%0개수d"%숫자 = "{인덱스:0개수d}".format(숫자)    "{인덱스:%의 특수문자(02d,.3f등)}".format()
- "%0개수.자릿수f"%숫자 = "{인덱스:0개수.자릿수f}".format(실수) 이때 숫자개수는 .과 그 이하를 모두 포함한다.

- "{인덱스(포맷에서의 인덱스):채우기(0,공백등)|정렬|길이|.자릿수|자료형}".format(,), "1.png"는"{0:03d}.{1}".format(int(x.split(".")[0]),x.split(".")[1])처럼 사용(1=그대로).
- format(숫자, ','), '%길이s' % format(숫자, ',')(오른쪽정렬), '{인덱스:,}'.format(숫자) = 천단위 ,기호 삽입.

# set
***
- 세트 = 딕셔너리처럼 {}에 저장. 각 값은 ,로 구분.
- 순서가 정해져있지 않아 매번 순서가 다름. 값이 중복될 수 없고 인덱스를 지원하지 않음.
- in, not in 으로 세트안에 값이 있는지 없는지 판단.
- set(문자열등 반복가능 객체) 로 세트 생성. 중복되는 문자는 하나만 들어감. 빈세트는 =set().
- set 는 안에 set 를 넣을 수 없고, frozenset 라는 안의 요소 변경불가의 세트는 frozenset 를 안에 넣을 수 있음.

## set calc
***
- 세트|세트 , set.union(세트1,세트2) = 합집합.
- 세트&세트 , set.intersection(세트1,세트2) = 교집합.
- 세트-세트 , set.difference(세트1,세트2) = 차집합. (앞에서 뒤와 겹치는걸 뺌)
- 세트^세트 , set.symmetric_difference(세트1,세트2) = 대칭자집합. (XOR)
- |= = .update() = 더함.
- &= = .intersection_update() = 겹치는 요소만 저장.
- -= = .difference_update() = 앞에서 뒤를 뺀것만 저장.
- ^= = .symmetric_difference_update() = 겹치지 않는 요소만 저장.
- <= = .issubset() = 앞에게 뒤의 부분집합인지 확인. 겹치지 않는 진부분집합은 < .
- \>= = .issuperset() = 앞에게 뒤의 상위집합인지 확인. 겹치지 않는 진상위집합은 >.
- == ,!= 으로 서로 같은지 다른지 확인.
- .isdisjoint() = 앞에게 뒤에것과 겹치는게 없으면 참. 있으면 거짓반환.

## set attribute
***
- .add(요소) = 세트에 요소추가.
- .remove(요소) = 요소 제거, 없으면 오류.
- .discard(요소) = 요소제거, 없으면 패스.
- .pop() = 랜덤요소 제거 후 반환. 요소가 없으면 에러.
- .clear() = 모든요소 삭제.
- len(세트) = 세트길이반환.
- .copy() = 세트 복사.
- 세트 안에서도 for, if 같은 표현식 사용 가능. if는 참이여야 출력.

# file
***
- 파일객체 = open("파일이름","파일모드") > 파일 열기
- 파일객체.write("문자열") > 파일에 쓰기. 여러줄 작성은 반복문 + \n으로 가능.
- 변수 = 파일객체.read() > 파일에서 \[문자열] 읽기
- 파일객체.close() > 파일닫기.
- with open("파일이름", "파일모드") as 파일객체:
-   코드 >>> 식으로로 파일 오픈 시 닫을 필요 없음.
- 파일객체.writelist(리스트)는 리스트를 하나씩 파일에 넣음. \n 없으면 한줄로 넣음.
- 파일객체.readlines()는 파일의 내용을 한 줄 씩 리스트로 가져옴.
- 파일객체.readline()은 파일을 한 줄씩 읽음. 더이상 읽을 줄이 없으면 ""(빈 문자열)반환.
- for 에 파일객체를 저장하면 파일을 한 줄씩 읽어오고, 파일의 줄 수를 알고있다면 a,b,c=f 식으로 언패킹하는 것도 가능 함.

## kind of open type
***
- r : 읽기모드. 파일이 없으면 에러.
- r+ : 읽기 또는 쓰기 모드. 파일이 없으면 에러, 기존파일 위에 덮어씀.
- w : 쓰기모드. 파일이 없으면 생성.
- w+ : 읽기 또는 쓰기 모드. 파일이 없으면 새로생성. 파일 초기화 후 씀. 
- a : 파일 추가 쓰기모드. 파일이 없으면 새로 생성. 파일의 끝으로 이동해 씀.
- a+ : 읽기 또는 파일 추가 모드. 파일이 없으면 새로 생성.
- ?t : '?'모드를 텍스트 모드로 엶.
- ?b : '?'모드를 바이너리 모드로 엶.

## file import
***
- 파일생성후 import 파일명, 파일명.파일속 함수이름() 으로 그 파일속 함수를 가져올 수 있다. .변수명으로 변수도 가져올 수 있고, 
  from 함수명 import 파일명으로 그 함수만 가져올 수 있으며, 이렇게 가져온건 파일명없이 그냥 함수만 쓸 수 있다.
- import 파일명 as 별명으로 파일명대신 변명.함수()로 사용할 수 있다.

## file pickle, glob
***
- pickle : 메모리에 올라가 있는 data 그 자체를 dump, load 를 통해 외부에 저장하고 사용하는 것.
- import pickle , open("파일명","wb(write binary)")로 파일 오픈 후
- pickle.dump(객체,파일명)으로 파일에 객체저장. 한 줄 씩 입력됨. 파이썬에 존재하는 모든것이 입력가능함.
- 마찬가지로 import, open("파일명","rb")로 파일 오픈 후
- 변수=pickle.lode(파일객체)로 객체로드. 여러번 쓰면 한 줄 씩 가져옴.

- from glob import glob
- glob(파일명) > 인자로 받은 패턴과 이름이 일치하는 모든 파일과 디렉터리의 리스트를 반환.

# function
***
- def 함수명():
-   코드  >>> 로 함수 생성. (a,b)식으로 변수 지정도 가능하고, return 도 사용가능. return 에서 , (튜플처리)로 여러개 반환 가능. 혹은 리스트등도 반환가능.
- def 바로 밑에 """이렇게""" 독스트링(주석)작성가능. 함수명._doc_로 독스트링 출력 가능.
- __함수(변수도 동일)\__, 함수 >> public | _함수 >> protected | __함수 >> private.
- [매개변수: 자료형\] : 매개변수에 자료형 지정 가능. list[자료형\]식으로, Sequence 내부의 자료형까지 지정 가능.
- [함수명() -> 자료형\] : 함수 반환자료형 지정 가능.

## element
***
- 위치인수 : 함수에 인수를 순서대로 넣는 방식. 인수를 순서대로 넣을 때는 리스트나 튜플을 사용할 수도 있음. 리스트 또는 튜플 앞에 *를 붙여서 함수에 넣어주면 됨(언패킹).
 단 개수가 다르면 오류 발생.
- 가변인수 : 함수 선언시 함수명(*변수명) 으로 선언(args). 인수를 마음대로 넣을 수 있음(안 넣는것도 가능). 넣은 인수들은 튜플로 들어감. 
  사용시엔 for 문 등으로 사용하고, 리스트등은 언패킹 필요, 고정변수와 같이 쓰면 고정이 제일 앞으로 와야 함.
- 키워드인수 : 함수 호출시 키워드=값 으로 사용. 함수쪽 변수명만 기억하면 순서를 맞추지 않아도 됨. sep,end 등도 키워드 인수.
- 딕셔너리의 키를 키워드와 같게 한 후 (**딕셔너리)로 딕셔너리의 값을 삽입 가능. 키는 무조건 문자열이여야하며 매개변수의 이름과 키 이름, 값쌍의 개수와 변수의 개수가 같아야 한다.
- 키워드 가변인수 : 함수 선언시 (**변수명)으로 선언(kwargs). 입력은 키워드=값 혹은 딕셔너리 언패킹, 결과물은 딕셔너리. for 과 .item()등으로 키와 값을 뽑아, 
  in 으로 값이 있는지 확인 후 사용. 다른 인수와의 순서는 고정>가변>가변(키워드).
- 함수 선언시 변수에 값을 할당하면 초깃값. 따로 지정하지 않으면 초깃값으로 나옴. 초깃값이 없는 변수는 항상 있는 변수보다 앞에 있어야 함.

## lambda
***
- 람다(lambda)표현식 :  (함수가 될)변수 = lambda 매개변수(들) : 식  으로 사용. 람다식 자체에 ()를 씌워 사용할 수도 있고, 람다식의 식에서는 변수를 만들수는 없으나 
  이미 있는 변수를 사용할 수는 있다.
- 매개변수가 없는 람다식은 그냥 :만 붙이면 되고, 이것은 함수를 인수로 사용할 때 주로 사용한다(ex-map 의 자료형 부분에 함수명을 써줄수도 있는데, 이때 람다로 쓰면 줄수가 줄어듦).
- 람다식에서 조건부 표현식 사용 : lambda 매개변수들: 식1 if 조건식 else 식2 의 형식. 조건이 맞으면 식1,아니면 식 2로 반환. 여기에선 else 가 필수이며, elif 를 사용할 수 없다.
- map(lambda x, y: x * y, a, b)처럼 맵은 반복가능 변수를 여러개 넣을 수 있고, 이때는 람다식에 변수를 여러개 넣어주면 된다.
- filter(함수, 반복가능한객체)로 사용. 함수의 반환값이  True 인것만 가져옴. map 처럼 따로 리스트로 감싸주거나 해야함. 여기에도 람다로 and 등을 사용해 써주면 편함.

## global, closer
***
- 함수 안에서 전역변수를 선언,변경하려면 global 로 선언해주면 되고, 바깥쪽 지역변수를 안쪽에서 변경하려면 nonlocal 키워드를 사용하면 된다.

- 어떤 함수에서 변수를 선언하고, 그 안에서 또 함수를 만들어 그 자체를 반환하거나 람다 표현식을 반환했을때, 바깥 함수의 반환값을 변수에 저장한 후 그 변수로 안쪽 함수를 사용하면,
  바깥쪽 함수 안에있는 변수를 계속 쓸 수 있다.
- 이게바로 클로저. 클로저의 변수를 변경하고 싶으면 nonlocal 키워드를 사용(바깥과 동일한 이름에다 nonlocal 을 붙여 선언)하면 되고, 보통 람다표현식과 같이 쓴다.

# class
***
- class 클래스이름:
-  def 메서드(self,기타등등):
-    코드
- 형식으로 클래스생성. 인스턴스(변수명)=클래스() 로 인스턴스생성.
- 인스턴스.메서드()로 인스턴스 메서드 사용. 메서드 안에서 클래스 안의 다른 메서드를 호출할 때는 self.메서드()로 호출한다.
- isinstance(인스턴스,클래스)로 인스턴스가 클래스에 속해있는지 확인한다. 맞으면 True,아니면 False 반환.

## class element
***
- 클래스에서 속성을 만들때는
- def \_\_init__(self)://인스턴스 생성시마다 호출됨.
- self.속성=값   으로 할당함. 변수생성같이 그 클래스 안에서 쓰거나, 호출하여 값을 바꾸거나 할 수 있다.

- def \_\_init__(self, name, age, address):
-     self.name = name
-     self.age = age
-     self.address = address
- 처럼 매개변수를 넣고, 초기화 해 인스턴스를 만들때 값을 받을 수 있다. 인스턴스를 만들때 매개변수로 health=health, mana=mana, 
  ability_power=ability_power 처럼 변수=init 속 매개변수를 사용해 변수를 특정 매개변수에 넣을 수 있다.
- 이때는 a=클래스명(매개변수들)처럼 인스턴스를 생성한다.

- 속성제작시에 *args 로 위치인수(리스트를 언패킹해서 인스턴스 생성시 넣음,self.name=args[0\]처럼 값 저장),**kwargs 로 키워드인수(딕셔너리 언패킹 또는 [키워드:인수\],
  self.name=kwargs["name"\]처럼 값 저장)를 사용할 수 있다.

- 클래스를 pass 로 채워 빈 클래스로 만든 뒤, 인스턴스를 만들고 거기에 없는 속성에 값을 할당하면 계속해서 속성추가를 할 수 있지만, 이는 그 인스턴스에만 적용된다.
- __init__이 아닌 다른 메서드에서 속성을 추가하면 그 메서드를 호출해야만 속성이 생긴다.
- _\_slots\__ = \['속성이름1, '속성이름2']처럼 만들기를 허용하고 싶은 속성만 넣으면 다른 속성은 생성이 제한된다.
- self.__속성 = 비공개 속성. 클래스 안에서만(클래스안의 메서드에서만 접근가능, 그 메서드를 호출해서 사용.) 사용가능.
- def __메서드 로 비공개 메서드, __속성 = 값으로 비공개 클래스 속성도 만들 수 있음.

## class global
***
- class 클래스이름:
-     속성 = 값     처럼 클래스 밑에 바로 속성을 만들어 클래스 속성(클래스에 속해있으며 모든 인스턴스에서 공유)을 만들 수 있다. 
  클래스 속성을 메서드등에서 사용하려면 클래스명.속성 으로 사용한다.
- 파이썬은 인스턴스, 클래스 순으로 찾기 때문에 같은 이름이 없다면 인스턴스.속성 으로 써도 되지만, 이러면 공유되기도 하고 의도와 달라질 수 있으니 클래스명.속성으로 사용.
- 클래스 속성: 모든 인스턴스가 공유. 인스턴스 전체가 사용해야 하는 값을 저장할 때 사용
- 인스턴스 속성: 인스턴스별로 독립되어 있음. 각 인스턴스가 값을 따로 저장해야 할 때 사용

### class deco
***
- 클래스에서 메서드를 만들 때 위에 @staticmethod 를 붙여 정적 메서드로 만들면 바로 클래스.메서드()로 호출할 수 있다. 이 정적메서드는 인스턴스 속성은 사용 불가하다.
- 인스턴스의 내용을 변경해야 할 때는 인스턴스 메서드, 인스턴스에는 변화 없이 결과만 구하면 될 때에는 정적 메서드로 사용한다. 정적 메서드에서는 self 를 매개변수로 넣어주지 않아도 된다.

- 메서드 위에 @classmethod 를 붙이면 클래스 메서드 제작. 클래스 메서드는 첫번째 매개변수에 cls 를 지정해야 함. 클래스 메서드는 메서드 안에서 클래스 속성, 
  클래스 메서드에 접근해야 할 때 사용하고, cls 는 클래스 이므로 메서드 안에서 인스턴스 = cls()나 return cls()처럼 해서 인스턴스를 만들 수 있음.
- @property 로 getter, @함수(변수)이름.setter 로 setter 를 간단히 구현할 수 있다.

## class extends
***
- class 기반클래스이름:
-   코드
- class 파생클래스이름(기반클래스이름):
-   코드   로 클래스를 상속시킬 수 있다. 이러면 파생클래스에서도 기반클래스의 모든 요소들을 사용할 수 있다.
- 클래스 상속은 연관되면서 동등한 기능일 때, 같은 종류이며 동등한 관계일때 사용한다. 영어로는 is-a 관계라고 함.
- issubclass(파생클래스, 기반클래스)로 기반클래스의 파생클래스가 맞는지 확인 할 수 있다. boolean 으로 반환.

- 파생클래스에서 기반클래스의 속성을 사용하려면 기반클래스의 __init__메서드를 호출해줘야 한다. 그러지 않으면 속성이 생성되지 않기 때문이다.
- 이때는 파생클래스에서 super().\_\_init__() 으로 기반클래스의 __init__메서드를 호출한다.
- 파생클래스에서 __init__메서드를 사용하지 않았다면 자동으로 기반클래스의 __init__이 호출되므로 super()을 사용할 필요 없다.
- super(파생클래스, self).메서드 로 현재클래스를 명확하게 표시할 수도 있다. 이 경우 기능에는 차이가 없다.

## override
***
- 메서드 오버라이딩: 파생클래스에서 기반클래스의 메서드를 재정의. 원래기능을 유지하면서 새로운 기능을 덧붙일때 사용.
- def greeting(self):
-  super().greeting() 형식으로 사용. 이 뒤에 다른 코드를 덧붙이는 식으로(이 경우, 기반클래스의 인삿말 안녕하세요를 출력하게 한 뒤 다른 인삿말을 추가했음) 사용한다.

## multiple extends
***
- class 파생클래스이름(기반클래스이름1, 기반클래스이름2): 형식으로 다중상속을 할 수 있다.
- 클래스 A를 상속받아서 B, C를 만들고, 클래스 B와 C를 상속받아서 D를 만드는 형식을 다이아몬드 상속이라고 하는데, 
  이 경우 위의 셋 모두 같은 이름의 메서드를 가지고 있다면 어떤 메서드를 호출해야 할지 애매해짐.
- 이 경우 파이썬에서는 메서드 탐색순서를 따르는 데, 이건 클래스.mro()(클래스.\_\_mro__ 형식도 같은 내용)로 확인힐 수 있다. 
  \[<class '\_\_main__.D'>, <class '\_\_main__.B'>, <class '\_\_main__.C'>, <class '\_\_main__.A'>, <
  class 'object'>]형식으로 출력됨.(object 클래스는 모든 클래스의 조상. 모든 클래스는 이 클래스를 상속받음.)
- 즉, 상속 단계가 가까운 것 부터, 왼쪽에서 오른쪽 순서로 탐색함.

## abstract class
***
- 추상클래스:from abc import *로 abc 모듈의 모든 클래스와 메서드를 가져온 후(abc.ABCMeta, @abc.abstractmethod 사용)
- class 추상클래스이름(metaclass=ABCMeta):
-  @abstractmethod
-  def 메서드이름(self):
-   pass(추상메서드는 직접 호출될 일이 없기 때문에 빈 메서드로 만듦)로 사용. 상속받는 클래스에서 클래스의 정의를 강제하기 위해 사용. 추상클래스의 모든 추상 메서드를 구현해야함.


### has a class
***
- 동등한 클래스가 아니라 어떤 클래스들을 관리하는 클래스를 만드려면 리스트 속성에 self.person_list.append(person)식으로 인스턴스들을 넣어 관리한다.
- 이 경우, PersonList 는 Person 을 가지고 있다고 할 수 있으며, 이런 관계를 포함관계, 영어로는 has-a 관계라고 한다.

### about class
***
- Math 패키지(파이썬 내장) > sqrt(값):제곱근 | pow(값,지수):값의 지수제곱 반환 | abs(값):절댓값 반환
- (collections 모델 import)클래스명 = collections.namedtuple('자료형이름', ['요소이름1', '요소이름2'\])로 각 요소에 이름을 지정해주는 namedtuple 생성.
- 인스턴스 = 클래스(값1,값2)/클래스(요소1=값1,요소2=값2)로 인스턴스 생성, 인스턴스.요소1/인스턴스[인덱스\]로 요소 접근. 클래스를 따로 만들고 
  __init__으로 요소를 만들기보다 요소만 쓰는데 유용한듯.
- 믹스인 : 다른 클래스에서 사용할 수 있도록 공통적인 메서드를 모아 놓은 클래스. HelloMixIn 같은 방식으로 사용.

# try
***
- try:
-   실행할 코드
- except:
-   예외가 발생했을 때 처리하는 코드 로 예외처리. try 에서 오류 발생시 바로 expect 로 감.
- expect 예외이름: 으로 특정 예외만 처리. expect 를 여러개 사용해서 특정 예외에는 특정 코드를 사용하게 할 수 있음.
- expect 예외 as 변수(주로 e): 로 변수에 예외메세지를 받아올 수 있음.
- expect Exception as 변수: 로 모든 예외의 에러 메세지를 받아 올 수 있음.
- 예외가 여러개 발생하면 먼저 발생했거나 높은 계층의 예외 메세지가 출력된다.

- try: 이것들은 함수가 아니니 try 안에서 만든 변수도 바깥에서 사용할 수 있다.
- expect:
- else: 로 예외가 발생하지 않았을때 실행할 코드를 지정할 수 있음. expect 생략 불가.
- finally: 로 예외 여부와는 상관없이 항상 실행할 코드를 지정할 수 있다. expect,else 생략 가능.

# raise
***
- raise 예외이름('에러메시지') 로 예외를 발생시킬 수 있다.
  (if절 안에 넣어서 에러를 발생시키는 등, 에러명은 이미 있는 에러명으로. 그 에러를 에러메세지와 발생상황만 다르게 해 발생시키는 것.)
- raise 를 try 밖에서 사용하면 그 코드블록 안에서 except 를 찾아 실행하고, except 가 없으면 그대로 그냥 오류가 발생해 실행이 종료된다.
- except:
- raise 로 현재 예외를 다시 발생시켜 상위 코드블록(함수면 함수 밖의 expect 에서 같이)의 except 에서 예외처리.
- raise 예외이름("예외메세지")로 다른 예외를 지정하고 에러메세지를 넣을 수도 있음.

## assert
***
- assert 조건식/assert 조건식,에러메세지 로 조건식이 거짓이면 AssertionError 발생,참이면 그냥 넘길 수 있다. 주로 나와선 안 되는 조건을 검사할 때 사용한다.
- assert 는 디버깅모드에서만 실행되며(파이썬 기본이 디버깅모드), 실행되지 않게 하려면 python -O 스크립트파일.py 처럼 실행시키면 된다.

### make Exception
***
- class 예외이름(Exception):
-  def \_\_init__(self):
-   super().\_\_init__('에러메시지') 로 직접 예외를 만들 수 있다.

# iter
***
- 이터레이터(반복자) : 값을 차례대로 꺼낼 수 있는 객체
- 이터레이터는 차례대로 반복하다 예외를 발생시켜 반복을 끝낸다.
- dir(객체):객체의 메서드 확인. 메서드중 __iter__이 있으면 반복가능 객체.
- it = \[1, 2, 3].\_\_iter__() 처럼 변수에 리스트의 이터레이터를 저장한 후 it.\_\_next__()같이 \_\_next__()로 차례대로 꺼낼 수 있음.
- 마지막 요소 이후 \_\_iter__()사용시 StopIteration 예외가 발생함.

- 시퀀스객체 :요소의 순서가 정해져있고, 연속적. 반복가능 객체에 속함. 리스트,튜플,문자열,range.
- 반복가능객체 :요소의 순서와는 상관 없이 요소를 한 번에 하나씩 꺼낼 수 있음. 시퀀스객체+딕셔너리,세트.
- 이터레이터 : \_\_next__ 메서드를 사용해서 차례대로 값을 꺼낼 수 있는 객체. 이터러블 객체에서 \_\_iter__()를 사용해 이터레이터로 바꿀 수 있음.
- 이터러블 : 반복 가능한 객체. \_\_next__ 없이 \_\_iter__만 가지고 있음. 리스트,세트,문자열 등. for문의 경우 이터러블객체에서 이터레이터를 얻어 값을 하나씩 꺼내옴.

- iter(이터러블 객체,반복을 끝낼값), iter(lambda : random.randint(0, 5), 2) 등 iter() 메서드 사용가능
- next(이터러블 객체, 기본값)으로 반복할 수 있을 때는 해당 값을 출력하고, 반복이 끝났을 때는 기본값을 출력하게 할 수 있음.

## make iter
***
- 클래스에 __iter__과 __next__를 모두 구현하거나 __getitem__을 구현하면 이터레이터를 만들 수 있음(이터레이터 프로토콜 지원).

- \_\_iter__: return self 처럼 자기를 그대로 리턴함.
- \_\_next__: __init__에서 받은 stop 과 정의한 current 를 이용해
- self.current += 1
-  if self.current < self.stop:
-   return self.current
-  else:
-   raise StopIteration 처럼 만들면 된다. if self.current * self.multiple < self.stop: 처럼 다른 변수를 이용해도 된다.

- \_\_getitem__(self, 인덱스): 로 인덱스로 접근할 수 있는 이터레이터 생성.
-        if index < self.stop:
-            return index   #index와 같은 수를 반환. 아니면 다른 식을 넣어도 된다.
-        index+=1
-        if index<self.stop-self.start: //인덱스 지정이 없으면 0부터 시작인듯.
-            return "{0:02d}:{1:02d}:{2:02d}".format(((self.time+index)//3600),((self.time+index)%3600//60),((self.time+index)%3600%60)) 같은식.
-        else: raise IndexError 처럼 코드를 짜면 된다. 사용은 Counter(3)[2]나 for i in Counter(3): 처럼 하면 된다.

# generator
***
- 제너레이터:이터레이터 생성 함수. 이터레이터보다 훨씬 간단하게 작성 가능.
- yield 값 을 연속해서 써 이터레이터를 만들 수 있음. yield(생산하다,양보하다.): 값을 함수 바깥으로 전달하며 코드 실행을 함수 바깥에 양보하고,
  전달한 값은 next 의 반환값으로 나옴. 제너레이터에서 return 에 반환값을 주면 StopIteration 예외에 에러메세지로 들어감.
- yield i.upper()처럼 함수를 호출하면 그 함수의 반환값을 전달함.
- yield from 반복가능객체 로 반복가능객체의 요소들을 하나씩 밖으로 전달.
- 리스트 표현식에서 []를 ()로 바꾼 것 처럼 (식 for 변수 in 반복가능한객체 -조건식-)로 제너레이터 표현식을 만들 수 있음.

## coroutine
***
- 코루틴: 특정 시점에 상대방의 코드를 실행. 메인 루틴과 코루틴의 코드를 번갈아가며 실행한다.
- yield : 평범한 함수에 무한 반복문과 yield를 사용해 코루틴(제네레이터 기반)으로 만들 수 있고, 아래의 최초 실행시 yield까지 함수를 실행시킨다.  
- 코루틴을 계속 유지시키기 위해 무한 루프를 사용하고, next()나 send(NONE)로 코루틴 객체를 최초 실행하여 코루틴의 동작을 실행한다.
- 코루틴.send(값) 으로 코루틴에 값을 보내며 코드를 실행할 수 있고, 값=(yield) 로 send 메서드가 보낸 값을 받아 올 수 있다.
- 코루틴에서 변수 = (yield 변수)로 값을 받아 오면서 값을 밖으로 보낼 수 있고, 변수 = 코루틴객체.send(값),변수=next(코루틴)으로 yield 에서 보낸 값을 받아 올 수 있다.
- 코루틴.close 로 코루틴을 종료할 수 있다. 이때는 GeneratorExit 예외가 발생한다.
- 코루틴.throw(예외이름, 에러메세지)로 코루틴에 예외를 발생시킬 수 있고, 코루틴에 except 를 사용할 수 있는데, 그 안에서 yield 를 사용하면 throw 의 반환값으로 나온다.
- 변수 = yield from 코루틴()으로 코루틴 내에서의 return 반환값을 받아올 수 있다.
- 이때 변수가 있는 상위 코루틴에 값을 보내도 하위 코루틴에서 값을 받고, 하위 코루틴에서 yield 로 값을 보내면 그걸 그대로 다시 밖으로 보냄.
### asyncio
- asyncio : 비동기 프로그래밍을 위한 모듈. CPU작업과 I/O를 병렬로 처리하게 해줌.
- 네이티브 코루틴 : 제너레이터기반 코루틴(yield)과 달리 async로 만든 코루틴.  
- [async def 함수명():] : 비동기(async)함수 선언(네이티브 코루틴 선언)
  
- loop = asyncio.get_event_loop()  : 이벤트 루프를 얻음.
- loop.run_until_complete(async함수()) : 함수가 끝날 때까지 기다림.
- loop.close() : 루프 종료.
  
- [await 코루틴/퓨처/태스크 객체] : 해당 객체가 끝날때까지 기다린 뒤 결과를 반환. 네이티브 코루틴 내부에서만 사용가능. 코루틴 안에서 다른 코루틴 실행시 사용.
- 퓨처/태스크 : asyncio.Future- 미래에 할일을 표현하는 클래스. 할일 취소/상태확인/완료/결과설정에 사용. | asyncio.Task- 퓨처의 파생클래스. 퓨처의 기능과 실행할 코루틴객체를 포함.
- [await asyncio.sleep(i)] : 함수 내부에서 i초만큼 sleep. 네이티브 코루틴이기에 await과 함꼐 사용해줘야 함.
- asyncio.run(async함수()) : 함수 실행.

# decorator
***
- 데코레이터:@로 시작. 메서드를 장식. 장식자라고도 함. 함수를 수정하지 않은 상태에서 추가 기능을 구현하고 싶을 때 사용.
- 호출할 함수를 매개변수로 받은 후 추가할 기능을 담은 함수를 만들고, 그것을 반환하는 식으로 제작가능.
- 함수 위에 @데코레이터를 사용해 함수 호출시마다 데코레이터 사용. 데코레이터를 여러개 사용하는 것도 가능하며, 이 때는 위에서 부터 실행한다.

## make deco
***
- 매개변수와 반환값이 있는 함수의 데코레이터는, 바깥의 함수는 여전히 함수를 인수로 받아 내부 함수를 반환하게 하고, 데코레이터 내부의 함수에서 
  호출할 함수의 매개변수와 같은 매개변수를 지정하고, 함수에 변수들을 넣어 호출한 후, 그 반환값을 변수에 저장하고, 그것을 리턴하게 내부함수를 만들면 된다.
- 매개변수의 개수가 고정되어있지 않다면 가변인수함수로 만들어주면 된다. 매개변수를(*args, **kwargs)식으로 받은 후, 같은식으로 언패킹해서 함수에 넣어주면 된다. 
  이때, 위치인수와 키워드 인수를 모두 받을 수 있도록 둘 다 지정해준다.
- 클래스 안의 메서드에 데코레이터를 사용하려면 내부 함수의 첫번째 매개변수를 self(클래스 메서드는 cls)로 해주어야 하며, 내부함수에서 func를 
  호출할 때에도 self 를 첫번째 매개변수로 넣어줘야 한다.

- 데코레이터에서 매개변수를 사용하려면 가장 바깥을 매개변수를 받는 함수로 싸준다음 가장 바깥에서 데코레이터를 반환하게 하며, 사용은 @데코레이터(인수)로 한다.
- 데코레이터를 여러개 사용하면 그 함수의 이름이 아닌 내부 함수의 이름이 나올 수 있는데, 이때는 functools 모듈의 wraps 데코레이터를 사용해  
  @functools.wraps(func)식으로 내부함수 위에 지정해준다. 원래 함수의 정보를 유지시켜주어 유용하다.

## class deco
***
- 클래스로 데코레이터를 만들때는 먼저 호출할 함수를 초깃값으로 받아 속성으로 저장한 뒤, __call__함수를 만들어 함수의 앞 뒤로 실행할 명령을 지정한 뒤
  사이에 self.func()로 받은 함수를 실행하게 한다.
- 사용시에는 다른 데코레이터와 마찬가지로 @로 사용하거나, 데코레이터(함수)로 인스턴스 생성 후 인스턴스를 호출하면 된다.
- 클래스로 매개변수와 반환값을 처리할 때도, __call__함수에 self 와 실행할 클래스의 매개변수(*args,**kwargs)를 매개변수로 받고,
  함수 실행시에 매개변수를 넣고, 반환값을 따로 받아 그것을 반환하게 하면 된다.
- 매개변수가 있는 데코레이터는 __init__에서 사용할 매개변수를 받고, __call__에서 func 를 매개변수로 받고,
  그 안에 wrapper(a,b)같이 사용할 매개변수가 있는 함수를 생성한다.

- def type_check(type_a, type_b): > 데코레이터가 받을 매개변수
-  def real_decorator(func): > 실제 데코레이터. 감쌀 함수를 인수로 받음
-    def wrapper(a, b): > 어떻게 장식할지를 작성, 감쌀 함수의 인수를 매개변수로 받음.
     혹시 func 에 리턴이 있다면, r을 반환시킬 때 앞뒤로 감쌀 문자열도 같이 반환해야 반환값만 뒤로 밀려나지 않음.
- 이런식으로 데코레이터를 작성.

# regular expression
***
- 정규 표현식 : 일정한 규칙을 가진 문자열을 표현하는 방법.
- 문자열 판단 : re 모듈의 match 함수(문자열 처음부터 매치되는지 판단)에 re.match('패턴', '판단할 문자열')식으로 넣어 패턴(있는지 검사할 문자)이 있으면 매치객체가 반환되고, 
  없으면 아무것도 반환하지 않음. 문자열.find("문자열")과 같은 기능.
- 문자열 판단 (하나라도) : re.match('hello|world', 'hello') 처럼 지정된 문자열이 하나라도 포함되는지 판단함.
- 문자열 판단 (위치) :  re.search('패턴', '문자열')처럼 search 함수(문자열 일부분에서 매치되는지 판단)에 "^문자열"로 맨 앞에 오는지, 
  "문자열$"로 맨 뒤에 오는지 판단함. 그 범위로 시작하는지 보는 건 ^[범위\]\*/+, 끝나는지 보는건 [범위\]*/+$이다.
- 문자열 판단 (숫자로?) : re.match('\[0-9]*', '1234') 처럼 숫자의 범위는 []에 0-9식으로 표현하며, *는 0개이상. +는 1개이상인지 판단한다.
- 문자열 판단 기호(+,\*) : a+b 일때는 a도 b도 하나 이상 있어야 하고, a*b일 때는 b만 있어도 매칭된다.
- 문자열 판단 기호(하나만) : 문자? 나 범위? 는 그 문자나 범위가 0개 또는 하나인지 판단하고('abc?d'식), .은 .의 위치에 아무 문자나 숫자가 1개 있는지 판단한다("ab.d"식).
- 문자열 판단 개수 : 문자{개수} 와 (문자열){개수}, \[범위]{개수}로 그 문자(열)이 개수만큼 있는지 판단한다.
- 문자열 판단 개수(범위) : 문자{시작 개수,끝 개수}로 그 개수 범위 안에 문자개수가 들어가는지 판단함.
- 문자열 판단 (혼합 범위) : \[A-Z0-9] 처럼 범위 두개를 서로 붙여서 표현. 이 경우는 대문자,숫자가 없이 소문자만 있다면 매칭되지 않음. 
  한글의 경우도 가-힣 처럼 나올 수 있는 한글 조합을 정해주면 된다.
- 문자열 판단 (혼합 범위 벗어남) : \[^A-Z0-9] 처럼 범위 앞에 ^를 붙이면 해당하는 범위를 벗어나는지 판단함. 포함되지 않아야 매칭.
- 문자열 판단 (특수문자) : \특수문자 로 그 특수문자가 범위에 들어가는지 판단할 수 있다. 특수문자가 범위([])에 들어가 있으면 붙이지 않아도 되지만, 오류가 난다면 붙이면 된다. 
  '[$()a-zA-Z0-9\]+'같은식.
- 문자열 판단 (단순 숫자,문자) : \d > 모든 숫자, \D > 숫자 제외 모든 문자, \w > 영문대소문자+숫자+밑줄, \W > \w제외 모든 문자(한글이나 다른 특수문자등). 
  이런식으로 간단하게 표현할 수 있다. '\d+'식으로 사용.
- 문자열 판단 (공백) : " "로 처리해도 되고, \s: [ \t\n\r\f\v\], \S: [^ \t\n\r\f\v\](공백 제외 다른 문자만 포함) 으로 간단하게 사용할 수 있다.
- 같은 정규표현식을 자주 사용한다면 객체 = re.compile('패턴'), 객체.match/search('문자열') 로 메서드를 호출하는게 더 효율적이다.

## grob
***
- 그룹 :  패턴에 넣는 문자열을 (정규표현식) (정규표현식)처럼 묶어서 만듦.
- 매치객체.group(그룹숫자) 로 해당 그룹에 매칭된 문자열을 가져올 수 있음. 숫자에 0을 넣거나 넣지 않으면 모든 문자열을 한꺼번에 반환한다.
- (?P<이름>정규표현식)으로 그룹에 이름을 지정할 수 있고, 매치객체.group('그룹이름')으로 사용할 수 있다.
- re.findall('패턴', '문자열')으로 패턴에 매칭되는 모든 문자열을 리스트의 형태로 가져올 수 있다.
- (.[a-z\]+)*는 점과 영문 소문자가 1개 이상 있는지 판단하고, 이것 자체가 0개 이상인지 판단함. 즉,  반드시 지켜야 하지만 있어도 되고 없어도 되는 상황에 사용.

## sub
***
- re.sub('패턴', '바꿀문자열', '문자열', 바꿀횟수)로 문자열을 바꿀 수 있고, 횟수를 생략하면 모든 문자열을 바꾼다.
- re.sub('패턴', 교체함수(매치객체를 매개변수로 받아 바꿀 문자열을 반환. 람다표현식을 사용하는 것도 가능함.), '문자열', 바꿀횟수)로도 사용할 수 있다.
- 패턴에서 그룹을 묶은 뒤 바꿀 문자열에서 '\\2 \\1 \\2 \\1'형식으로 지정해주면, 그 그룹에 매치된 문자열을 그 위치에 사용할 수 있다.
- 그룹에 이름을 지었다면, \\g<이름>형식으로도 매칭된 문자열을 지정할 수 있다.
- 문자열 앞에 r을 붙이면 원시 문자열이 되어 \를 붙이지 않아도 특수문자를 판단할 수 있게되어 r'\숫자 \g<이름> \g<숫자>'처럼 \를 하나만 붙여서 사용할 수 있게 된다.

# pip
***
- pip > 원도우용 파이썬에는 기본 내장, 리눅스 : 리눅스, macOS$ curl -O https://bootstrap.pypa.io/get-pip.py(curl 설치 필요), 맥OS : 
  $ sudo python3 get-pip.py 로 설치할 수 있다.
- (Window 기준) pip install 패키지명 으로 패키지를 설치할 수 있고, -m(모듈실행 옵션)을 python 과 pip 사이에 넣어 실행할 수도 있다.
- pip search 패키지: 패키지 검색
- pip install 패키지==버전: 특정 버전의 패키지를 설치(예: pip install requests==2.9.0)
- pip list 또는 pip freeze: 패키지 목록 출력
- pip uninstall 패키지: 패키지 삭제

- 모듈(module): 변수, 함수, 클래스 등을 모아 놓은 스크립트 파일.
- 패키지(package): 여러 모듈을 묶은 것

# import
***
- import 모듈 as 별명 > 모듈 이름대신 별명으로도 구동 가능.
- from 모듈 import 변수,함수,클래스 > 모듈.변수로 쓸 필요 없이 그냥 변수만 쓸 수 있다. 그 함수만 사용할 때 유용. *로 쓰면 모든 변수,함수,클래스를 가져온다. 
  클래스의 경우 모듈.클래스로 사용해야 하니 이 기능을 쓰면 좋다.
- from 모듈 import 변수 as 변명 > 가져온 변수,함수,클래스에 별명을 붙인다.
- from 모듈 import 변수 as 이름1, 함수 as 이름2, 클래스 as 이름3 > 여러개를 가져오며 각각에 이름을 붙인다.
- import 를 해제하려면 del 모듈 로 할 수 있고, 다시 가져오려면 importlib 모듈의 reload 를 사용하면 된다.
- import 패키지.모듈, import 패키지.모듈1, 패키지.모듈2 로 패키지와 모듈을 가져올 수 있고 여기에 as를 사용하면 패키지.모듈 대신 별명만 사용할 수 있고 
  from 도 from 패키지.모듈 import 변수 식으로 사용한다..

- 같은 폴더에 있는 파일(모듈)은 그냥 import 모듈로 사용할 수 있다.
- __name__은 직접 실행한 파일일 경우 __main__이 반환되고, 아니면 그 파일(모듈)의 이름이 반환된다. 패키지의 모듈일 경우 패키지.모듈이름 이 반환된다.

## about import
***
- \_\_all__ = ["패키지","의 요소들"\] 로 *을 통해 모든 요소를 불러올때 공개할 것들의 목록을 지정할 수 있다.
- 현재 폴더에 모듈, 패키지가 없으면 path 에서 찾는데, 이건 sys 모듈의 path 함수로 볼 수 있다. 그 안의 site-packages 는 pip 로 설치한 패키지가 들어가는데, 
  가상환경을 만든다면 가상환경/Lib/site-packages 폴더에 들어간다.
- 파이썬은 하위 패키지를 만들 수 있고, 하위패키지의 모듈을 가져 올 떄는 계층순서대로 .을 붙여(.operation.element)가져오면 된다. 
  하위패키지에서 옆의 패키지를 가져 올 때는 ..(상위폴더란 뜻, 위로 올라갈수록 .이 늘어남)패키지 로 불러올 수 있다.
- 파이썬에서 \_\_init__.py 파일은 폴더가 패키지로 인식되게 하기도 하고, 패키지를 초기화하는 역할도 한다. 즉 import 시에 이 파일이 실행된다. 
  __all__도 이 파일에서 해야 하고, 비워둘수도 있으며, 3.3이상에선 없어도 패키지로 인식된다. 근데 이게 비어있으면 from 이 안되는 듯.
- 이를 이용해 __init__파일에 from .(현재패키지) import 모듈  식으로 명령을 넣어 패키지만 가져와도 모듈도 같이 가져와 calcpkg.operation.add(10, 20)식으로 
  사용할 수 있게 만들 수 있다.
- 패키지를 import 할때 from .모듈 import 변수, 함수, 클래스 를 사용하면 앞에 모듈을 붙일 필요 없이 변수만 사용할 수 있다. from .모듈 import * 을 사용해도 된다.
- 모듈과 패키지(\_\_init__)의 첫줄에 '''모듈의 독스트링'''처럼 독스트링을 넣을 수 있고, 이걸 출력하려면 .__doc__를 출력하면 된다.

# collections
***
- collections : 표와 인덱싱등 데이터를 다룰때 특히 유용한 라이브러리 모듈. 데이터처리를 위한 유용한 객체가 많이 있음. dict()의 기본 API사용가능.
- collections.Counter() : 카운터객체 생성. 딕셔너리와 동일하게 키/값 형식으로 되어있으나 최초 키 추가시 0으로 자동초기화됨. 
  .mostcommon(n)으로 빈도수 순 정렬로 받을 수 있음(n생략가능).
- collections.defaultdict(list) : defaultdict객체 생성. 하나의 키를 여러 값에 맵핑가능. 인자로 주어진 객체의 기본값을 초깃값으로 사용.
- collections.deque(maxlen=n) : deque객체 생성. 마지막 n개의 객체만을 유지.   

# appendix
***

## time
***
- time.time() : 현재시간 반환. 단위는 sec. 함수 시작 전과 후의 차이를 이용해 함수의 실행시간을 구할 수 도 있음.
- time.sleep(n) : sleep. n초를 sleep함. n은 실수도 가능.
- time 모듈의 localtime 함수를 이용하면 UTC 가 아니라 KST 로, 날짜와 시간 형태로 변환해준다.
- time.strftime('포맷', time.localtime(time.time())) 로 원하는 포맷으로 사용할 수 있다.

## byte
***
- bytes : 바이트 단위의 값을 연속적으로 저장하는 시퀀스 객체.
- bytes(길이): 정해진 길이만큼 0으로 채워진 바이트 객체를 생성
- bytes(반복가능한객체): 반복 가능한 객체로 바이트 객체를 생성 의 두가지 방법으로 만들 수 있다,
- ''나 ""앞에 b를 붙이면 바이트객체가 됨

### byte array
***
- bytearray : bytes 와 같지만 요소변경 가능.
- bytearray(): 빈 바이트 배열 객체를 생성
- bytearray(길이): 정해진 길이만큼 0으로 채워진 바이트 배열 객체를 생성
- bytearray(반복가능한객체): 반복 가능한 객체로 바이트 배열 객체를 생성

## encoding
***
- 파이썬에서 문자열의 기본 인코딩은 UTF-8인데, 바이트객체로 만들면 ASCII 코드로 저장해 그걸로 처리하고 싶을 때 바이트 객체를 사용한다.
- .encode() : 문자열을  바이트 객체로 바꿀때 사용. ("인코딩")처럼 인코딩을 지정해주면 해당 인코딩으로 된 바이트 객체로 만듦.
- .decode() : 바이트 객체를 문자열로 바꿈. 이때도 뒤에 특정 인코딩을 지정하면, 그 인코딩으로 된 바이트 객체를 디코딩함.
- bytes("값", encoding='인코딩') 식으로 인코딩을 지정하여 객체를 생성할 수 있다.

## other
***
- eval('문자열') : 문자열 형태의 파이썬 코드를 실행하고 결과를 반환 / repr(객체) > 파이썬 인터프리터에서 실행할 수 있는 문자열을 반환
- chr(코드값) : ASCII 코드값에 해당하는 문자를 반환 / ord(문자) > 문자의 ASCII 코드를 반환
- hex(정수) : 16진수 / oct(정수) > 8진수 (둘다 문자열로)
- bin(정수) : 2진수 변환 / int('2진수문자열', 2) > 2진수 10진수 변환
- math.isclose(0.1 + 0.2, 0.3) : 두 실수가 같은지 판단.
- 파이썬의 제작자는 귀도 반 로섬.

# Virtual environment
***
- python -m venv 가상환경이름 을 가상환경을 만들 폴더에서 사용하면 가상환경 폴더 생성
- 그 폴더로 이동해 .\Scripts\Activate.bat 파일을 실행하면(혹은 activate 실행)가상 환경이 활성화됨. 이 명령을 실행한 파이썬의 버전이 가상환경의 버전이 됨.
- 성공적으로 가상환경을 만들면 (가상환경이름)이 표시되는데, 그 상태에서 pip 로 패키지를 설치하면 \Lib\site-packages 안에 패키지가 저장되며 그 패키지에서만 사용할 수 있다.
- [pip freeze > requirements.txt] : requirements.txt 파일에 설치된 패키지 목록 저장. 그 목록대로 설치하려면 pip install -r requirements.txt , 삭제하려면 uninstall.
- 가상환경 폴더를 옮겼다면 activate.bat, Activate.ps1, activate 파일 안의 VIRTUAL_ENV 부분을 이동시킨 폴더 경로로 수정.
- PyCharm 에서 가상 환경을 사용하려면 File > Settings... > Project > Project Interpreter 에서 오른쪽의 톱니바퀴 버튼을 클릭하고, 
  Add Local 을 클릭하고 가상 환경의 파이썬 인터프리터(python.exe)를 추가해주면 됨.

# json
***
- json : json 모듈 import 후 .json 형식의 파일을 열어 json.load(파일객체)로 파이썬의 객체에 저장할 수 있다.
- 파이썬 객체를 json 문자열로 변환하려면 json.dump(객체-딕셔너리?)로 통과시켜줘야 한다. 가독성을 위해 
  (객체, indent=들여쓰기할 숫자,sort_keys=True(키 중심으로 정렬))등을 사용할 수 있다.
- API : API 의 url 을 문자열에 저장한 후 request 모둘의 get(url) 함수로 변환한 후, 그걸 다시 읽을 수 있게 get 한 객체.text 로 변환하고, 
  그걸 json.load 로 json 파일로 변환한다. 그 후, API 의 참조 파일을 참고해 데이터의 종류를 파악한다.

# argparse
- argparse : 명령행 인터페이스를 쉽게 작성하도록함. sys.argv를 어떻게 파싱할지 파악하며, 도움말과 사용법메세지를 자동 생성하고, 잘못된 인자를 줄 때 에러를 발생시킴.
- parser = argparse.ArgumentParser() : ArgumentParser객체 생성. description(도움말 전에 표시될 텍스트)등의 인자 사용가능. 
- parser.add_argument(옵션명) : 프로그램 인자에 대한 정보를 추가. 명령행의 문자열을 객체로 변환하는 방법을 알려줌. 옵션명은 리스트로 여러개를 지정해 줄 수도 있음.
- add_argument인자 : action(인자발견시 수행할 액션의 기본형), nargs(소비되야하는 인자의 수), const(일부action및nargs선택시 필요상숫값), 
  default(인자가 명령행에도 namespace에도 없뇬으면 생성되는 값), type(명령행인자가 변환되야 할 형), choices(인자로 허용되는 값의 컨테이너),
  required(명령행 옵션 생략가능여부), help(인자기능에 대한 간단한 설명), metavar(사용메세지에 사용되는 인자명), dest(parse_args()의 반환객체에 추가될 속성이름).
- args = parser.parse_args() : 인자를 파싱. 명령행 검사 -> 인자를 적절한 형으로 변환 -> 적절한 액션을 호출. sys.argv에서 자동으로 명령행인자 결정.
- args.accumulate(args.인자명) : 해당 인자의 값을 가져옴.

- sys.argv : 파이썬 스크립트에 전달된 명령줄 인자의 리스트. argv[0\]은 스크립트 이름, 인터프리터에 이름이 전달되지 않으면 빈 문자열.

# threading | 병렬실행
- threading : 기본적으로 하나의 메인쓰레드가 코드를 순차적으로 실행하는 파이썬에서 코드를 병렬로 실행하기 위해 별도의 쓰레드를 생성하는 모듈.
  파이썬에는 전역 인터프리터 락킹이 있어, 특정 시점에 하나의 코드만 실행하는데, 이 때문에 인터리빙 방식으로 코드를 분할해 실행하며,
  다중 CPU에서의 병렬실행을 위해서는 multiprocessing(다중프로세스 이용)모듈을 사용해야 함.
- t = threading.Thread() : 쓰레드 객체 호출. target인자에 쓰레드가 실행할 함수를 주고, args(kwargs)인자에 해당 함수의 인자를 넣어 쓰레드를 실행 할 수 있음.
- 파생클래스 제작 : threading.Thread를 상속하는 클래스를 제작 후 run(쓰레드가 실제 실행하는 메서드)를 재정의하는 방식으로도 사용이 가능함.
- t.start() : 쓰레드를 실행함.

- 데몬쓰레드 : 백그라운드에서 실행되는, 메인쓰레드가 종료되면 즉시 종료되는 쓰레드. 일반 쓰레드는 메인이 끝나도 자신의 작업이 끝날때까지 계속 실행.
- t.deamon = True : 데몬쓰레드로 설정.

# git
***
- git clone (깃허브 디렉토리 주소) .(현재 디렉토리) : github 디렉토리의 파일을 전부 복사해옴
- git diff : 마지막 수정 이후 추가한 내용을 알려줌
- git add (더할 파일) : 필드(커밋시 git에 등록될 파일이 있는 공간)에 올림
- git commit -m "(버전-설명-)" : 컴퓨터 내의 git에 등록.
- git log : 생성한 버전 보여줌
- git push : 컴퓨터에 저장된 git파일을 깃허브에 등록.
- git status : 상태(수정한 부분)보여줌

- .gitignore : 깃에서 관리하지 않을, 무시할 파일/디렉토리를 정의한 파일. 프로젝트 최상위에 존재해야 함.
- 규칙 : '#'로 시작하는 라인은 무시 | 평범한 파일형식(*.a등)사용 | '/'로 시작하면 하위 디렉토리에 미적용('/dir/\*.a'면 /dir/subdir/의 a파일은 미적용)
  | 디렉토리는 '/'를 끝에 사용해 표시(없으면 확장자가 없는 파일처리) | '!'로 시작하는 패턴의 파일은 무시하지 않음 | 파일/디렉토리등을 입력시 해당 파일/디렉토리를 무시.

- git lfs(LargeFileStorage) : git에서 100MB이상의 파일을 관리하기위한 프로그램. add/push이전에 사용해줘야 함.
- git lfs install : 실행한 리포지토리를 lfs의 관리하에 넣음.
- git lfs track "*.확장자" : 해당 확장자의 파일을 관리함.

- BFG Repo-Cleaner : 원치 않는 데이터 제거 등을 지원하는 오픈소스 도구.
- [java -jar (bfg파일경로+bfg파일명).jar --strip-blobs-bigger-than 100M (.git파일명).git] : 해당 깃 레포지토리 사용. 제거할 파일이 있는 레포지토리를 사용해야 함.
- [java -jar (bfg파일경로+bfg파일명).jar --delete-files(-D) (삭제할파일)] : 삭제 파일 등록. 파일 삭제.
- [git reflog expire --expire=now --all && git gc --prune=now --aggressive] : 파일 삭제 확정. 이 이후 push를 실행하면 됨. 
